/** TODO
*/
/*
MakeDocXL.ahk

Scans a script file for function declarations then outputs a simple Doc.ahk

Example function declaration in script:
	FileRename(SourcePattern = "", DestPattern = "", Overwrite = "-Overwrite") {
		FileMove(SourcePattern, DestPattern, Overwrite)
	} ; FileRename(OldName, NewName, "Overwrite")

Example Doc output:
	FileRename(SourcePattern = "", DestPattern = "", Overwrite = "-Overwrite") {
		; FileRename(OldName, NewName, "Overwrite")

Options: FUTURe
	Preserve Whitespace?
	Trim Whitespace (tabs and multiple spaces to A_Space) = current default

======================================================================================================================
Name:						MakeDocXL.ahk
Description:		Merge all #Includes into one script file
AHK version: 		1.1.33.02 (U64)
LIB dependency:	AHKLX_LIB
Script version:	1.0.00/2021-01-06/jasc2v8
	0.0.1/Initial release
Credits:
Notes:
Legal Disclaimer:
	This is free and unencumbered software released into the public domain.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED WARRANTY.
	For more information, please refer to <http://unlicense.org>
======================================================================================================================	
*/
#SingleInstance, Force
#NoEnv
; #Warn
SendMode Input
SetWorkingDir %A_ScriptDir%
SetBatchLines, -1
;===========================
;
#Include <AHKLX_LIB>
;
;** globals
;
Global hGui, hEdit
Global DocBuffer
Global DocFilename
Global FileBuffer
Global LineCount := 0
Global NL := Chr(0x0d) . Chr(0x0a) ; Chr(13) . Chr(10) ; "`r`n" 
Global SelectedFile
Global SortBuffer
;
;** gui:
;
GuiTitle := "AHKLX Make Doc"
DefaultRootDir:=A_ScriptDir "\AHKLX_LIB_test.ahk"
;DefaultFilter:="" ; Default is (*.txt, *.*)
DefaultFilter:="AHK Files (*.ahk)"
; Generated by AutoGUI 2.6.2
Gui               +HwndhGui -Resize -MaximizeBox
Gui Font,         s12 Norm cBlack, Consolas
Gui Add, Text,		x16  y8  w829 h30,	File Select Prompt
Gui Add, Edit,		+HwndhEdit1 vSelectedFile	x16  y38 w829 h30 ;Edit1
Gui Add, Button,  +HwndhBtnBrowse x856 y38 w100 h30,	Browse
Gui Add, Edit,		+HwndhEdit vEditText x16  y80 w940 h340	+Multi ;Edit2  -Wrap +HScroll 
Gui Add, Button,	x16 y432 w100 h30, Clear
Gui Add, Button,	x128 y432 w96 h30, Sort
Gui Add, Button,	x238 y432 w96 h30, Doc
Gui Add, Button,	+HwndhBtnStart	x744 y432 w100 h30,	START
Gui Add, Button,	x856 y432 w100 h30, Cancel
Gui Show, w970 h480, %GuiTitle%

GuiControl(, hEdit1, DefaultRootDir) ;set unselected text
;debug ControlSelect(hBtnBrowse, hGui) ;focus and highlight
ControlSelect(hBtnSTART, hGui) ;focus and highlight
Return

ButtonStart:
	Gui, Submit, NoHide
	;Note SelectedFile := Edit1
	
	If (!FileExist(SelectedFile))
	{
		EditAppend("FILE_NOT_FOUND: " SelectedFile)
		Return
	}

	FileBuffer := FileRead(SelectedFile)
	
	if (ErrorLevel)
	{	
		EditAppend("READ_ERROR: " SelectedFile)
		Return
	}

	StartTick := A_TickCount
	EditAppend("Start   : " FormatTime(A_Now,"yyyy-MM-dd_HH:mm:ss"))

	Gosub ScanFile
	Gosub WriteDoc
	
	ElapsedTick := A_TickCount - StartTick
	EditAppend("Finish  : " FormatTime(A_Now,"yyyy-MM-dd_HH:mm:ss"))
	EditAppend("Elapsed : " ElapsedTick "ms")
Return

ButtonBrowse:
Gui, Submit, NoHide
;Note that SelectedFile := Edit1 vSelectedFile 
RootDir := SelectedFile
Prompt:="Select file"
Filter:=DefaultFilter
SelectedFile := FileSelectFile(RootDir, Prompt, Filter)
if (SelectedFile = "") {
	EditAppend("No file selected.")
	Return
}
ControlSetText(hEdit1, SelectedFile)
Return

ButtonSort:
	Gui, Submit, NoHide
	;Note SelectedFile := Edit1
	if (FileExist(SortFilename))
		Run, edit %SortFilename%	
Return

ButtonDoc:
	Gui, Submit, NoHide
	;Note SelectedFile := Edit1
	if (FileExist(DocFilename))
		Run, edit %DocFilename%
Return

ButtonClear:
EditClear()
Return

ButtonCancel:
Escape::
GuiEscape:
GuiClose:
Gui, Destroy
ExitApp
;
;Edit Functions
;
EditAppend(pText, LineNumbers := False)
{
	vText := ControlGetText(hEdit)
	if LineNumbers {
		LineCount++
		vText .= Format("{:0.4i}: {}", LineCount, pText)
	}
	vText .= pText "`r`n" 		
	ControlSetText(hEdit, vText)
	ControlSend(hEdit, "{End}")
	;ControlSend(hEdit, "{Home}") ; if HScroll
}

EditClear()
{
	LineCount := 0
	ControlSetText(hEdit)
}

ScanFile:

DEBUG := False
;DEBUG
;OK FileAppend(FileBuffer, "FILE_BUFFER.TXT")

	SortBuffer := ""
	CommentSection := False
	FunctionBlock := False
	FunctionMaybe := False
	
	;OmitChars %A_Space%%A_Tab% will be removed from the beginning and end (but not the middle) of A_LoopField
	Loop, Parse, FileBuffer, `n, `r%A_Space%%A_Tab%
	{	
	
		;Parse will strip NL chars so we have to add them back in below, except lines to be joined
		Line := A_LoopField
		
		;	Skip blank lines
		if (Line = "")
			Continue
			
		LineLTrim := LTrim(Line)
		
if (DEBUG) {
MsgBox Line=`n`n%Line%`n`nLTrim=%LineLTrim%
}
		
;MsgBox FunctionBlockEnd_SavedFunction=`n`n%SavedFunction%`n`nBraceCount=%BraceCount%
		
		; flag start of comment section, save first line of DocComment section
		if ( (SubStr(LineLTrim, 1, 2) = "/*" ) ) {
			CommentSection := True
			if ( SubStr(LineLTrim, 1, 3) = "/**" ) 
				SortBuffer .= line . NL
			Continue
		}
		
		; flag end of comment section
		if (SubStr(LineLTrim, 1, 2) = "*/") {
			CommentSection:=False
			Continue
		}

		; skip comment section
		if (CommentSection) {
			Continue
		}
		
		;	;** Save one-liner DocComment
		if ( (SubStr(LineLTrim, 1, 3) = ";**") ) {
			SortBuffer .= line  . NL
			Continue
		}

		;	Skip comments
		if (SubStr(LineLTrim, 1, 1) = ";")
			Continue
		
		;iterate through the previously flagged function block
		;this must appear before the function detect sections below
		;this alogrighim allows braces in the function block end comment
		if (FunctionBlock) {
			if (InStr(LineLTrim, "}") != 0 ) {
				BraceCount -= 1			
			} else if (InStr(LineLTrim, "{") != 0 ) {
				BraceCount += 1
			}
				
			if (BraceCount = 0) {
				FunctionBlock := False
				SortBuffer .= SavedFunction
				
if (DEBUG) {
MsgBox FunctionBlockEnd_SavedFunction=`n`n%SavedFunction%`n`nBraceCount=%BraceCount%
MsgBox FunctionBlockEnd_Line=`n`n%Line%`n`nBraceCount=%BraceCount%	
}
				pos := InStr(LineLTrim, ";")
				if (pos != 0) {
					doc_comment := Trim( SubStr(LineLTrim, pos) )
					if (doc_comment != "") {
						SortBuffer .= A_Space . doc_comment
					}
				}
				SortBuffer .= NL
			}
			Continue
		}
		
		; { block start
		if ( (SubStr(LineLTrim, 1, 1) = "{") and (FunctionMaybe) ) {
			FunctionMaybe := False
			FunctionBlock := True
			BraceCount := 1
if (DEBUG) {
MsgBox FunctionBlockConfirm=%Line%`n`nBraceCount=%BraceCount%
}
			Continue
		}
		
		; Function() { ;block start
		if ( (InStr(LineLTrim,"{") != 0 ) and (InStr(Line,")") != 0 ) ) {
			;if no space to the left of the "(" then this is function versus command
			if ( InStr( SubStr(LineLTrim, 1, Instr(LineLTrim,"(") ), A_Space) = 0  )  {
				FunctionBlock := True
				BraceCount := 1
				SavedFunction := Line
if (DEBUG) {
MsgBox FunctionBlockStart=%Line%`n`nBraceCount=%BraceCount%
}
				Continue
			}
		}
			
		; Function()
		if (SubStr(LineLTrim, 0) = ")") and (InStr(LineLTrim, "(") != 0) {
			if ( InStr( SubStr(LineLTrim, 1, Instr(LineLTrim, "(") ), A_Space) = 0 ) {
				; could be a function if next line starts with {
				FunctionMaybe := True
				SavedFunction := Line
if (DEBUG) {
MsgBox FunctionBlockMaybe=%Line%`n`nBraceCount=%BraceCount%
}
				Continue				
			}
		}

	}
	
	Sort, SortBuffer

	;now split the function and comment. Write the function first, then the comment on the next line
	DocBuffer := ""
		Loop, Parse, SortBuffer, `n, `r
	{
		pos := InStr(A_LoopField, ";")
		if (pos = 0) {
			DocBuffer .= A_LoopField . NL			
		} else {
			function := SubStr(A_LoopField, 1, pos-1)
			comment  := SubStr(A_LoopField, pos-1)
			DocBuffer .= function . NL
			DocBuffer .= comment . NL
		}
	}
Return ;End_ScanFile_Loop

WriteDoc:
	TimeStamp := FormatTime(now,"yyyyMMdd_HHmmss")
	DocFilename := SplitPath(SelectedFile).OutNameNoExt "_" TimeStamp "_Doc.ahk"
	r := FileAppend(DocBuffer, DocFilename)
	EditAppend("DocFile : " DocFilename)

	SortFilename := SplitPath(SelectedFile).OutNameNoExt "_" TimeStamp "_Sort.ahk"
	r := FileAppend(SortBuffer, SortFilename)
	EditAppend("SrtFile : " SortFilename)
Return

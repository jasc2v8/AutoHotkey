/*
======================================================================================================================
Name:						MakeApi.ahk
Description:		Scans a script file for function declarations then outputs a simple two-liner Api.ahk
								In:		AHKEZ.ahk
								Out:	AHKEZ_API.ahk
AHK version:		AHKL v1.1.33.02 (U64)
LIB dependency:	AHKEZ
Script version:	0.1.00/2021-02-13/jasc2v8
	0.0.00/Initial release
Credits:
Notes:

	Example function declaration in script:
		FileRename(SourcePattern = "", DestPattern = "", Overwrite = "-Overwrite") {
			FileMove(SourcePattern, DestPattern, Overwrite)
		} ; FileRename(OldName, NewName, "Overwrite")

	Example API output:
		FileRename(SourcePattern = "", DestPattern = "", Overwrite = "-Overwrite") {
			; FileRename(OldName, NewName, "Overwrite")

Legal: Dedicated to the public domain without warranty (CC0 1.0) <http://creativecommons.org/publicdomain/zero/1.0/>
======================================================================================================================	
*/
#SingleInstance, Force
#NoEnv
; #Warn
SendMode Input
SetWorkingDir %A_ScriptDir%
SetBatchLines, -1
;===========================
;
#Include <AHKEZ>
;
;** globals
;
Global hGui, hEdit
Global ApiBuffer
Global ApiFilename
Global FileBuffer
Global LineCount := 0
;Global NL := Chr(0x0d) . Chr(0x0a) ; Chr(13) . Chr(10) ; "`r`n" 
Global SelectedFile
Global SortBuffer
;
;** gui:
;
GuiTitle := "Make API"
DefaultRootDir:="C:\Users\Jim\Documents\Autohotkey\Lib\AHKEZ.ahk"
;DefaultRootDir:="D:\Software\DEV\Work\AHK\AHKLX\MakeDocLX\libs\RichEdit.ahk"
;DefaultFilter:="" ; Default is (*.txt, *.*)
DefaultFilter:="AHK Files (*.ahk)"
; Generated by AutoGUI 2.6.2
Gui               +HwndhGui -Resize -MaximizeBox
Gui Font,         s12 Norm cBlack, Consolas
Gui Add, Text,		x16  y8  w829 h30, Select Script:
Gui Add, Edit,		+HwndhEdit1 vSelectedFile	x16  y38 w829 h30, %DefaultRootDir% ;Edit1
Gui Add, Button,  +HwndhBtnBrowse x856 y38 w100 h30,	Browse
Gui Add, Edit,		+HwndhEdit vEditText x16  y80 w940 h340	+Multi ;Edit2  -Wrap +HScroll 
Gui Add, Button,	x16 y432 w100 h30, Clear
Gui Add, Button,	x128 y432 w96 h30, Sort
Gui Add, Button,	x238 y432 w96 h30, API
Gui Add, Button,	+HwndhBtnStart	x744 y432 w100 h30,	START
Gui Add, Button,	x856 y432 w100 h30, Cancel
Gui Show, w970 h480, %GuiTitle%

GuiControl(, hEdit1, DefaultRootDir) ;set unselected Text
;debug ControlSelect(hBtnBrowse, hGui) ;focus and highlight
ControlSelect(hBtnSTART, hGui) ;focus and highlight
Return

ButtonStart:
	Gui, Submit, NoHide
	;Note SelectedFile := Edit1
	
	If (!FileExist(SelectedFile))
	{
		EditAppend("FILE_NOT_FOUND: " SelectedFile)
		Return
	}

	FileBuffer := FileRead(SelectedFile)
	
	if (ErrorLevel)
	{	
		EditAppend("READ_ERROR: " SelectedFile)
		Return
	}

	StartTick := A_TickCount
	EditAppend("Start    : " FormatTime(A_Now,"yyyy-MM-dd_HH:mm:ss"))

	Gosub ScanFile
	Gosub WriteFiles
	
	ElapsedTick := A_TickCount - StartTick
	EditAppend("Finish   : " FormatTime(A_Now,"yyyy-MM-dd_HH:mm:ss"))
	EditAppend("Elapsed  : " ElapsedTick "ms")
Return

ButtonBrowse:
Gui, Submit, NoHide
;Note that SelectedFile := Edit1 vSelectedFile 
RootDir := SelectedFile
Prompt:="Select file"
Filter:=DefaultFilter
SelectedFile := FileSelectFile(RootDir, Prompt, Filter)
if (SelectedFile = "") {
	EditAppend("No file selected.")
	Return
}
ControlSetText(hEdit1, SelectedFile)
Return

ButtonSort:
	Gui, Submit, NoHide
	;Note SelectedFile := Edit1
	if FileExist(SortFilename)
		;Run, edit %SortFilename%	
		Run(SortFilename)
Return

ButtonAPI:
	Gui, Submit, NoHide
	;Note SelectedFile := Edit1
	if FileExist(ApiFilename)
		;Run, edit %ApiFilename%
		Run(ApiFilename)
Return

ButtonClear:
EditClear()
Return

ButtonCancel:
Escape::
GuiEscape:
GuiClose:
Gui, Destroy
ExitApp
;
;Edit Functions
;
EditAppend(pText, LineNumbers := False)
{
	vText := ControlGetText(hEdit)
	if LineNumbers {
		LineCount++
		vText .= Format("{:0.4i}: {}", LineCount, pText)
	}
	vText .= pText "`r`n" 		
	ControlSetText(hEdit, vText)
	ControlSend(hEdit, "{End}")
	;ControlSend(hEdit, "{Home}") ; if HScroll
}

EditClear()
{
	LineCount := 0
	ControlSetText(hEdit)
}

ScanFile:

DEBUG := FALSE
;DEBUG
;OK FileAppend(FileBuffer, "FILE_BUFFER.TXT")

	SortBuffer := ""
	CommentSection := False
	FunctionBlock := False
	FunctionMaybe := False
	
	;OmitChars %A_Space%%A_Tab% will be removed from the beginning and end (but not the middle) of A_LoopField
	Loop, Parse, FileBuffer, `n, `r%A_Space%%A_Tab%
	{	
	
		;Parse will strip NL chars so we have to add them back in below, except lines to be joined
		Line := A_LoopField
		
		;	Skip blank lines
		if (Line = "")
			Continue
			
		LineLTrim := LTrim(Line)
		
if (DEBUG) {
MsgBox Line=`n`n%Line%`n`nLTrim=%LineLTrim%
}
		
		; flag start of comment section
		if ( (SubStr(LineLTrim, 1, 2) = "/*" ) ) {		
			CommentSection := True
			
			;flag and save DocComment section
			if ( SubStr(LineLTrim, 1, 3) = "/**" ) {
				DocCommentSection := True
				SortBuffer .= line . NL
			}		
			Continue
		}
				
		; flag end of comment sections
		if ( SubStr(LineLTrim, 1, 2) = "*/" )  {
			CommentSection := False
		
			if (DocCommentSection) {
				DocCommentSection := False
				SortBuffer .= line . NL
			}
 			Continue
		}

		;save DocComments
		if (DocCommentSection) {
			SortBuffer .= line . NL				
			Continue
		}
		
		; skip comment section
		if (CommentSection) {
			Continue
		}
		
		;	;** Save one-liner DocComment
		if ( (SubStr(LineLTrim, 1, 3) = ";**") ) {
			SortBuffer .= line  . NL
			Continue
		}

		;	Skip comments
		if (SubStr(LineLTrim, 1, 1) = ";")
			Continue
		
		;iterate through the previously flagged function block
		;this must appear before the function detect sections below
		;this alogrithim allows braces in the function block end comment
		if (FunctionBlock) {
			if (InStr(LineLTrim, "}") != 0 ) {
				BraceCount -= 1			
			} else if (InStr(LineLTrim, "{") != 0 ) {
				BraceCount += 1
			}
				
			if (BraceCount = 0) {
				FunctionBlock := False
				SortBuffer .= SavedFunction
				
if (DEBUG) {
MsgBox FunctionBlockEnd_SavedFunction=`n`n%SavedFunction%`n`nBraceCount=%BraceCount%
MsgBox FunctionBlockEnd_Line=`n`n%Line%`n`nBraceCount=%BraceCount%	
}
				pos := InStr(LineLTrim, ";")
				if (pos != 0) {
					doc_comment := Trim( SubStr(LineLTrim, pos) )
					if (doc_comment != "") {
						SortBuffer .= A_Space . doc_comment
					}
				}
				SortBuffer .= NL
			}
			Continue
		}
		
		; { block start
		if ( (SubStr(LineLTrim, 1, 1) = "{") and (FunctionMaybe) ) {
			FunctionMaybe := False
			FunctionBlock := True
			BraceCount := 1
if (DEBUG) {
MsgBox FunctionBlockConfirm=%Line%`n`nBraceCount=%BraceCount%
}
			Continue
		}
		
		; Function() { ;block start
		if ( (InStr(LineLTrim,"{") != 0 ) and (InStr(Line,")") != 0 ) ) {
			;if no space to the left of the "(" then this is function versus command
			if ( InStr( SubStr(LineLTrim, 1, Instr(LineLTrim,"(") ), A_Space) = 0  )  {
				FunctionBlock := True
				BraceCount := 1
				SavedFunction := Line
if (DEBUG) {
MsgBox FunctionBlockStart=%Line%`n`nBraceCount=%BraceCount%
}
				Continue
			}
		}
			
		; Function()
		if (SubStr(LineLTrim, 0) = ")") and (InStr(LineLTrim, "(") != 0) {
			if ( InStr( SubStr(LineLTrim, 1, Instr(LineLTrim, "(") ), A_Space) = 0 ) {
				; could be a function if next line starts with {
				FunctionMaybe := True
				SavedFunction := Line
if (DEBUG) {
MsgBox FunctionBlockMaybe=%Line%`n`nBraceCount=%BraceCount%
}
				Continue				
			}
		}

	}
	
	;** debug Sort, SortBuffer

	;now split the function and comment. Write the function first, then the comment on the next line
	ApiBuffer := ""
		Loop, Parse, SortBuffer, `n, `r
	{
		pos := InStr(A_LoopField, ";")
		if (pos = 0) {
			ApiBuffer .= A_LoopField . NL			
		} else {
			function := SubStr(A_LoopField, 1, pos-1)
			comment  := SubStr(A_LoopField, pos-1)
			ApiBuffer .= function . NL
			ApiBuffer .= comment . NL
		}
	}
Return ;End_ScanFile_Loop

WriteFiles:
	;TimeStamp := FormatTime(now,"yyyyMMdd_HHmmss")
	;ApiFilename := SplitPathArray(SelectedFile).OutNameNoExt "_" TimeStamp "_Doc.ahk"
	ApiFilename := SplitPathArray(SelectedFile).OutNameNoExt "_API.ahk"
	FileWrite(ApiBuffer, ApiFilename)
	EditAppend("API File : " ApiFilename)

	;SortFilename := SplitPathArray(SelectedFile).OutNameNoExt "_" TimeStamp "_Sort.ahk"
	SortFilename := SplitPathArray(SelectedFile).OutNameNoExt "_Sort.ahk"
	FileWrite(SortBuffer, SortFilename)
	EditAppend("Sort File: " SortFilename)
Return

CleanLine(Line) {
	Line := ReplaceWhiteSpaceWithA_Space(Line)		
	Line := RemoveComment(Line)
	Return Line
}

RemoveComment(Haystack) {
	;AutoHotkey sees comments as a semicolon preceded by a space or tab
	Needle := "[ `t]+;.*"
	Return RegExReplace(Haystack, Needle)
}

ReplaceWhiteSpaceWithA_Space(Haystack) {
	;replace all spaces and tabs with a single space
	Return RegExReplace(Haystack, "[ \t]+", A_Space)
}




